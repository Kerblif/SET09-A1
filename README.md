## Отчет по экспериментальному исследованию алгоритмов сортировки строк

Приложенные графики (`sorting_performance_combined.png` и `sorting_performance_log_combined.png`) наглядно демонстрируют поведение алгоритмов.

**1. Анализ времени выполнения:**

*   **`Merge Sort` (Синяя линия):**
    *   Показывает стабильную производительность на всех типах данных. Графики времени близки к линейно-логарифмической зависимости `O(N log N)`.
    *   Эмпирическая оценка сложности (power ≈ 1.14-1.19) подтверждает `O(N log N)`.
    *   Несколько медленнее `Quick Sort` на случайных данных, но не деградирует на отсортированных или обратно отсортированных.

*   **`Quick Sort` (Оранжевая линия):**
    *   Демонстрирует хорошую производительность, часто опережая `Merge Sort` на случайных и почти отсортированных данных. Реализация с рандомизированным выбором опоры и 3-х дорожечной разбивкой помогает избегать квадратичной деградации на отсортированных/обратно отсортированных данных, что видно по графикам и оценке сложности (power ≈ 1.03-1.09, интерпретируется как `O(N log N)`).
    *   Теоретически, без рандомизации или специальной обработки, `Quick Sort` мог бы показать `O(N^2)` на упорядоченных данных, но используемая реализация этого избегает.

*   **`Radix Sort` (MSD) (Зеленая линия):**
    *   **Случайные данные (`Random`):** Показывает наилучшее время выполнения, опережая `Merge Sort` и `Quick Sort`. Это соответствует теоретической оценке `O(D*N)` (где D - средняя длина строк или максимальная глубина рекурсии), которая при фиксированном D близка к `O(N)`. Эмпирическая оценка (power ≈ 0.92) подтверждает линейную зависимость.
    *   **Отсортированные данные (`Sorted`):** Также очень быстр, оценка (power ≈ 0.94) близка к `O(N)`.
    *   **Обратно отсортированные (`Reverse Sorted`), Почти отсортированные (`Almost Sorted`), С общим префиксом (`Common Prefix`):** На этих типах данных производительность `Radix Sort` несколько хуже, чем на случайных, и приближается или даже уступает `Quick Sort` на больших размерах. Эмпирическая оценка сложности для этих случаев (power ≈ 0.94-0.95) интерпретируется скриптом как `O(N log N)`, что может быть связано с тем, что для этих данных глубина рекурсии (эффективное D) растет с N, или эвристика скрипта не идеально точна. Теоретически, MSD Radix Sort должен оставаться эффективным, если строки достаточно разнообразны после общего префикса или если "почти отсортированность" не создает слишком много пустых "корзин". Графики показывают, что рост все же более пологий, чем у `N log N` алгоритмов.

*   **`Radix+Quick Sort` (Красная линия):**
    *   Показывает производительность, очень близкую к `Quick Sort` на большинстве типов данных. Переключение на `Quick Sort` для малых подмассивов (размером < 256) эффективно устраняет накладные расходы `Radix Sort` на большое количество мелких рекурсивных вызовов.
    *   На случайных данных он немного уступает чистому `Radix Sort`, так как часть работы все равно выполняется `Quick Sort`.
    *   Эмпирическая оценка сложности (power ≈ 1.02-1.06) на всех типах данных интерпретируется как `O(N log N)`. Это логично, так как на больших размерах доминирует `Radix` (ближе к `O(N)`), а на множестве мелких подзадач - `Quick Sort` (в сумме дающий `O(N log N)` для этих частей).

**2. Анализ количества сравнений:**

*   **`Merge Sort` и `Quick Sort`:** Количество сравнений растет в соответствии с `O(N log N)`. `Quick Sort` обычно выполняет немного меньше сравнений на случайных данных.
*   **`Radix Sort` и `Radix+Quick Sort`:** Эти алгоритмы не являются чисто "сравнительными" в том же смысле. Они распределяют элементы по "корзинам" на основе значений символов. "Сравнениями" в коде считались обращения к символам строк (`charAtPos`).
    *   **`Radix Sort`:** На случайных данных показывает наименьшее количество "сравнений" (доступов к символам), что отражает его эффективность.
    *   **`Radix+Quick Sort`:** Количество "сравнений" (доступов к символам) выше, чем у чистого `Radix Sort`, так как включает сравнения, выполняемые `Quick Sort` на малых подмассивах.
    *   **Данные с общим префиксом (`Common Prefix`):** Здесь количество "сравнений" (доступов к символам) для `Radix Sort` и `Radix+Quick Sort` заметно выше, чем для других типов данных (кроме случайных). Это связано с тем, что первые символы одинаковы, и алгоритмам приходится "пропускать" их, углубляясь в строки, что увеличивает эффективное D и, следовательно, количество обращений к символам. График для `Common Prefix` имеет самый крутой наклон для поразрядных сортировок.

**3. Сравнение с теоретическими оценками:**

*   **`Merge Sort` и `Quick Sort` (адаптированный):** Эксперименты подтверждают ожидаемую сложность `O(N * L * log N)` или `O(N log N)` операций со строками, где каждая операция может потребовать до `L` (длина строки) посимвольных сравнений в худшем случае. Использование LCP оптимизирует это. Результаты (power ≈ 1.0-1.2) в целом соответствуют `N log N` по количеству операций со строками.
*   **`MSD Radix Sort`:** Теоретическая сложность `O(D * (N + R))`, где `D` – длина ключа (максимальная длина строки или глубина), `N` – количество строк, `R` – мощность алфавита. Если `D` и `R` считать константами, то `O(N)`.
    *   На случайных и отсортированных данных это подтверждается (power ≈ 0.92-0.94).
    *   На данных с длинными общими префиксами или специфической структурой `D` может перестать быть "малой константой", и поведение может отклоняться от чисто линейного. Скрипт интерпретировал некоторые случаи как `O(N log N)`, что может указывать на рост эффективного `D` с `N` или ограничения эвристики.
*   **`MSD Radix+Quick Sort`:** Сочетает преимущества обоих. На верхних уровнях рекурсии (большие подмассивы) – `O(D_eff * N)`, на нижних (малые подмассивы) – `O(k * log k)` для каждого из многих малых подмассивов, где `k` – размер подмассива. Суммарное поведение близко к `O(N log N)` или очень эффективному `O(N)`, в зависимости от данных. Полученные оценки (power ≈ 1.02-1.06) хорошо это отражают.

**Выводы:**

1.  **`MSD Radix Sort`** является наиболее эффективным алгоритмом для сортировки строк на **случайных данных** и **данных, уже отсортированных**, как по времени, так и по количеству обращений к символам.
2.  **`Quick Sort`** (с использованными оптимизациями) показывает отличную универсальную производительность, являясь хорошим выбором, если структура данных заранее неизвестна или если `Radix Sort` показывает деградацию (например, на некоторых типах данных с длинными общими префиксами без достаточного разнообразия после них).
3.  **`MSD Radix+Quick Sort`** является хорошим компромиссом, сочетая скорость `Radix Sort` на начальных этапах и стабильность `Quick Sort` на малых подмассивах. Его производительность очень близка к `Quick Sort`, но он может быть чуть быстрее на данных, где `Radix Sort` изначально очень эффективен.
4.  **`Merge Sort`** – самый предсказуемый и стабильный по времени, но обычно уступает другим рассмотренным алгоритмам на большинстве наборов данных для строк.
5.  Данные с **длинными общими префиксами** представляют особый вызов для строковых сортировок. Алгоритмы, основанные на сравнении строк целиком (как `Merge Sort`, `Quick Sort` с LCP), эффективно пропускают общие префиксы. `MSD Radix Sort` также пропускает их, но это увеличивает глубину рекурсии и, как следствие, общее количество операций.
6.  Эмпирические оценки сложности в целом хорошо согласуются с теоретическими, учитывая особенности строковых данных и реализации алгоритмов. Небольшие расхождения в интерпретации степени роста `Radix Sort` на некоторых данных могут быть связаны с влиянием средней длины строки `D` и характером распределения ключей.

**Рекомендации:**

*   Для задач, где требуется максимальная производительность на случайных или слабоструктурированных строковых данных, **`MSD Radix Sort`** является предпочтительным.
*   Если важна универсальность и хорошая производительность на широком спектре данных, включая частично упорядоченные, **`Quick Sort` (адаптированный для строк)** или **`MSD Radix+Quick Sort`** будут хорошим выбором.